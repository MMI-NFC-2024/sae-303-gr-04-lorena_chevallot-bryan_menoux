---
import * as d3 from "d3";
import fs from "fs";
import path from "path";
const assetsDir = path.join(process.cwd(), "src", "assets");
const rawText = fs.readFileSync(
  path.join(assetsDir, "pratiques_culturelles_2022@1.csv"),
  "utf8"
);

const rows = rawText
  .trim()
  .split("\n")
  .map((l) => l.split(","));
const headers = rows[0];
const data = rows.slice(1).map((r) => {
  let i = 0;
  while (i < r.length && isNaN(+r[i])) i++;
  const activite = r.slice(0, i).join(",").trim();
  const values = r.slice(i).map((v) => +v);
  const obj: any = { Pratique: activite };
  headers.slice(-values.length).forEach((h, j) => (obj[h.trim()] = values[j]));
  return obj;
});
const tidy: any[] = [];
for (const row of data) {
  for (const [key, value] of Object.entries(row)) {
    const numValue = typeof value === "number" ? value : NaN;
    if (key === "Pratique" || isNaN(numValue)) continue;
    tidy.push({
      Activité: row["Pratique"],
      Catégorie: key.trim(),
      Valeur: numValue,
    });
  }
}
const tidyJson = JSON.stringify(tidy);

const uniqueId = `graph-6-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="graph-container" data-graph-id={uniqueId}>
  <div class="plot-holder flex justify-center min-h-[400px] items-center">
    <div class="text-zinc-400">Chargement du graphique...</div>
  </div>
  <div class="tooltip"></div>
</div>
<style>
  .graph-container {
    position: relative;
    display: inline-block;
    width: 100%;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  .plot-holder {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  .plot-holder svg {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  .plot-holder text {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  .tooltip {
    display: none;
    position: fixed;
    background: rgba(0, 0, 0, 0.95);
    color: white;
    padding: 10px 14px;
    border-radius: 6px;
    font-size: 15px;
    font-weight: 600;
    font-family:
      system-ui,
      -apple-system,
      sans-serif;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    pointer-events: none;
    white-space: pre-line;
    line-height: 1.6;
    border: 1px solid rgba(255, 255, 255, 0.2);
    z-index: 1000;
  }
  /* Aligne parfaitement la légende au-dessus des cellules */
  .heatmap-frame {
    display: block;
  }
  .legend-row {
    display: block;
    margin-bottom: 6px;
  }
  .legend-row svg {
    display: block;
  } /* évite les espaces inline */
</style>
<script type="module" define:vars={{ tidyJson, uniqueId }}>
  const tidy = JSON.parse(tidyJson);

  async function renderPlot() {
    try {
      const Plot = await import(
        "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm"
      );
      const d3 = await import("https://cdn.jsdelivr.net/npm/d3@7/+esm");

      const container = document.querySelector(`[data-graph-id="${uniqueId}"]`);
      const holder = container?.querySelector(".plot-holder");
      const tooltip = container?.querySelector(".tooltip");
      if (!holder) return;

      const maxValue = d3.max(tidy, (d) => d.Valeur);

      // Dimensions + marges (identiques au plot)
      const plotWidth = 750;
      const plotHeight = 400;
      const marginLeft = 190; // même valeur que ton plot
      const marginBottom = 120; // idem

      // Échelle partagée
      const colorScale = {
        scheme: "YlGnBu",
        label: "Taux (%)",
        domain: [0, maxValue],
      };

      // Légende : largeur = largeur des cellules (sans la marge gauche)
      const legend = Plot.legend({
        color: colorScale,
        width: plotWidth - marginLeft,
      });

      // Heatmap (sans légende intégrée)
      const heatmap = Plot.plot({
        marginTop: 4,
        marginLeft,
        marginBottom,
        color: { ...colorScale, legend: false },
        x: { label: "Catégorie socioprofessionnelle", tickRotate: -45 },
        y: { label: null, domain: tidy.map((d) => d.Activité).reverse() },
        marks: [
          Plot.cell(tidy, {
            x: "Catégorie",
            y: "Activité",
            fill: "Valeur",
            stroke: "#fff",
            title: (d) =>
              `${d.Catégorie}\n${d.Activité} : ${d.Valeur.toFixed(1)} %`,
          }),
          Plot.text(tidy, {
            x: "Catégorie",
            y: "Activité",
            text: (d) => `${d.Valeur.toFixed(1)} %`,
            fill: (d) => (d.Valeur > maxValue * 0.5 ? "white" : "black"),
            fontSize: 11,
          }),
        ],
        width: plotWidth,
        height: plotHeight,
      });

      // Injection : on crée un wrapper de la largeur du plot, avec padding-left = marginLeft
      holder.innerHTML = "";
      const frame = document.createElement("div");
      frame.className = "heatmap-frame";
      frame.style.width = plotWidth + "px";

      const legendRow = document.createElement("div");
      legendRow.className = "legend-row";
      legendRow.style.paddingLeft = marginLeft + "px"; // aligne la légende avec les cellules
      legendRow.appendChild(legend);

      frame.appendChild(legendRow);
      frame.appendChild(heatmap);
      holder.appendChild(frame);

      // Tooltips
      const cells = holder.querySelectorAll("rect");
      const cellTitles = new Map();
      cells.forEach((cell) => {
        const t = cell.querySelector("title");
        cellTitles.set(cell, t?.textContent || "");
        if (t) t.remove();
        cell.removeAttribute("aria-label");
        cell.style.cursor = "pointer";
        cell.style.transition = "all 0.2s ease";
        cell.addEventListener("mouseenter", (e) => {
          if (!tooltip) return;
          tooltip.textContent = cellTitles.get(cell);
          tooltip.style.display = "block";
          tooltip.style.left = e.clientX + 10 + "px";
          tooltip.style.top = e.clientY + 10 + "px";
          cell.style.stroke = "#2563eb";
          cell.style.filter = "brightness(1.1) saturate(1.05)";
          cell.style.opacity = "0.95";
        });
        cell.addEventListener("mousemove", (e) => {
          if (!tooltip) return;
          tooltip.style.left = e.clientX + 10 + "px";
          tooltip.style.top = e.clientY + 10 + "px";
        });
        cell.addEventListener("mouseleave", () => {
          if (!tooltip) return;
          tooltip.style.display = "none";
          cell.style.stroke = "#fff";
          cell.style.filter = "none";
          cell.style.opacity = "1";
        });
      });

      // rAF pour assurer la mise en page au premier paint (évite un léger décalage)
      requestAnimationFrame(() => {
        // rien de plus à faire ici, mais garde la possibilité de tweaks si besoin
      });
    } catch (e) {
      console.error("Erreur heatmap/legend:", e);
    }
  }
  renderPlot();
</script>
