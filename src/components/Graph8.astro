---
import * as d3 from "d3";
import fs from "fs";
import path from "path";
const assetsDir = path.join(process.cwd(), "src", "assets");
const profText = fs.readFileSync(
  path.join(assetsDir, "professions-culturelles-departements-2017@1.csv"),
  "utf8"
);
const baseText = fs.readFileSync(
  path.join(assetsDir, "base_culturelle_nettoyee.csv"),
  "utf8"
);
const parseSemicolon = d3.dsvFormat(";");
const prof = parseSemicolon.parse(profText.replace(/\uFEFF/g, ""));
const base = d3.csvParse(baseText);
const normalizeCode = (c: any) => {
  if (c == null) return null;
  let s = String(c).trim().replace(".0", "");
  if (s === "2A" || s === "2B") return s;
  if (/^\d{5}$/.test(s)) s = s.slice(0, 2);
  return s.padStart(2, "0");
};
const lieuxParDep = d3.rollup(
  base
    .map((d) => ({ dep: normalizeCode(d["N_Département"]) }))
    .filter((d) => d.dep),
  (v) => v.length,
  (d) => d.dep
);
const acteursParDep = new Map(
  prof.map((r: any) => [
    normalizeCode(r["Code_insee"]),
    +r["Nombre d'actifs exerçant une profession culturelle_2017"] || 0,
  ])
);
const nomsParDep = new Map(
  prof.map((r: any) => [
    normalizeCode(r["Code_insee"]),
    r["Libelle_geographique"],
  ])
);
const fusion = Array.from(
  new Set([...lieuxParDep.keys(), ...acteursParDep.keys()])
)
  .map((dep) => {
    const acteurs = acteursParDep.get(dep) ?? 0;
    const lieux = lieuxParDep.get(dep) ?? 0;
    return {
      Code_departement: dep,
      Nom_departement: nomsParDep.get(dep) ?? null,
      Nombre_acteurs_culturels: acteurs,
      Nombre_lieux_culturels: lieux,
      Ratio_lieux_par_acteur: acteurs > 0 ? lieux / acteurs : null,
    };
  })
  .filter(
    (d) =>
      d.Nombre_acteurs_culturels > 0 &&
      d.Nombre_lieux_culturels > 0 &&
      d.Ratio_lieux_par_acteur != null
  )
  .sort((a, b) =>
    d3.ascending(a.Code_departement ?? "", b.Code_departement ?? "")
  );
const compress = (x: number) => Math.sqrt(Math.log1p(x));
const dataCompressed = fusion.map((d) => ({
  ...d,
  xComp: compress(d.Nombre_acteurs_culturels),
  yComp: compress(d.Nombre_lieux_culturels),
}));
const medianActeurs = d3.median(fusion, (d) => d.Nombre_acteurs_culturels) ?? 0;
const medianLieux = d3.median(fusion, (d) => d.Nombre_lieux_culturels) ?? 0;
function profile(d: any) {
  if (
    d.Nombre_acteurs_culturels >= medianActeurs &&
    d.Nombre_lieux_culturels >= medianLieux
  )
    return "Écosystème complet";
  if (
    d.Nombre_acteurs_culturels < medianActeurs &&
    d.Nombre_lieux_culturels < medianLieux
  )
    return "Territoire sous-doté";
  if (
    d.Nombre_acteurs_culturels < medianActeurs &&
    d.Nombre_lieux_culturels >= medianLieux
  )
    return "Tension humaine (beaucoup de lieux / peu d'acteurs)";
  return "Potentiel latent (beaucoup d'acteurs / peu de lieux)";
}
const dataCat = dataCompressed.map((d) => ({ ...d, profil: profile(d) }));
const dataCatJson = JSON.stringify(dataCat);
const compressedMedians = JSON.stringify({
  medianActeurs: compress(medianActeurs),
  medianLieux: compress(medianLieux),
});

const uniqueId = `graph-8-${Math.random().toString(36).substr(2, 9)}`;
---

<div class="graph-container" data-graph-id={uniqueId}>
  <div class="plot-holder flex justify-center min-h-[700px] items-center">
    <div class="text-zinc-400">Chargement du graphique...</div>
  </div>
  <div class="tooltip"></div>
</div>
<style>
  .graph-container {
    position: relative;
    display: inline-block;
    width: 100%;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  .plot-holder {
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  .tooltip {
    display: none;
    position: fixed;
    background: rgba(0, 0, 0, 0.95);
    color: white;
    padding: 10px 14px;
    border-radius: 6px;
    font-size: 15px;
    font-weight: 600;
    font-family:
      system-ui,
      -apple-system,
      sans-serif;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
    pointer-events: none;
    white-space: pre-line;
    line-height: 1.6;
    border: 1px solid rgba(255, 255, 255, 0.2);
    z-index: 1000;
  }
  /* Wrapper du scatter + légende */
  .scatter-frame {
    display: block;
  }

  /* Légende verticale au-dessus, alignée à gauche de la zone utile */
  .legend-vertical {
    display: block;
    margin: 2px 0 8px 0;
  }
  .legend-vertical svg {
    display: block;
  }

  /* Optionnel: espacement un peu plus dense entre items de légende */
  .legend-vertical .legend {
    row-gap: 4px;
  }
</style>
<script type="module" define:vars={{ dataCatJson, compressedMedians, uniqueId }}
>
  async function renderScatterResponsive() {
    const Plot = await import(
      "https://cdn.jsdelivr.net/npm/@observablehq/plot@0.6/+esm"
    );

    const dataCat = JSON.parse(dataCatJson);
    const { medianActeurs, medianLieux } = JSON.parse(compressedMedians);

    const container = document.querySelector(`[data-graph-id="${uniqueId}"]`);
    const holder = container?.querySelector(".plot-holder");
    const tooltip = container?.querySelector(".tooltip");
    if (!holder || !tooltip) return;

    // Mesure fiable de la largeur disponible
    const parentWidth = Math.max(
      320,
      Math.floor(holder.getBoundingClientRect().width || 0)
    );
    if (!parentWidth) return; // si layout pas prêt

    // Ratio & marges selon la largeur
    const isSmall = parentWidth < 640;
    const plotWidth = Math.min(parentWidth, 1100); // un max raisonnable
    const plotHeight = Math.max(
      420,
      Math.round(plotWidth * (isSmall ? 0.8 : 0.65))
    );

    const marginLeft = isSmall ? 56 : 70; // un peu plus large en desktop
    const marginTop = 10;

    // Légende (verticale) – couleurs/domaine identiques au plot
    const legendDomain = [
      "Écosystème complet",
      "Territoire sous-doté",
      "Tension humaine (beaucoup de lieux / peu d'acteurs)",
      "Potentiel latent (beaucoup d'acteurs / peu de lieux)",
    ];
    const legendRange = ["#22c55e", "#ef4444", "#f59e0b", "#3b82f6"];

    const legend = Plot.legend({
      color: { domain: legendDomain, range: legendRange, label: "Profils" },
      columns: 1, // vertical
      swatchSize: 14,
      label: "Profils",
      width: plotWidth - marginLeft, // même bord gauche que la zone utile
    });

    // Scatterplot
    const plot = Plot.plot({
      width: plotWidth,
      height: plotHeight,
      marginLeft,
      marginTop,
      grid: true,
      x: { label: "Nombre d'acteurs culturels (compressé) →", nice: true },
      y: { label: "↑ Nombre de lieux culturels (compressé)", nice: true },
      color: { domain: legendDomain, range: legendRange, legend: false },
      marks: [
        Plot.ruleX([medianActeurs], { stroke: "#555", strokeDasharray: "4,4" }),
        Plot.ruleY([medianLieux], { stroke: "#555", strokeDasharray: "4,4" }),
        Plot.dot(dataCat, {
          x: "xComp",
          y: "yComp",
          fill: "profil",
          r: 5,
          stroke: "#fff",
          strokeWidth: 1.2,
          opacity: 0.9,
          title: (d) =>
            `${d.Nom_departement ?? d.Code_departement}
${d.Nombre_acteurs_culturels.toLocaleString()} acteurs
${d.Nombre_lieux_culturels.toLocaleString()} lieux
Profil : ${d.profil}`,
        }),
      ],
    });

    // Injection (légende AU-DESSUS, alignée à gauche de la zone utile)
    holder.innerHTML = "";
    const frame = document.createElement("div");
    frame.className = "scatter-frame";
    frame.style.width = plotWidth + "px";

    const legendRow = document.createElement("div");
    legendRow.className = "legend-vertical";
    legendRow.style.paddingLeft = marginLeft + "px";
    legendRow.appendChild(legend);

    frame.appendChild(legendRow);
    frame.appendChild(plot);
    holder.appendChild(frame);

    // Tooltips
    const dots = holder.querySelectorAll("circle");
    const dotTitles = new Map();
    dots.forEach((dot) => {
      const t = dot.querySelector("title");
      dotTitles.set(dot, t?.textContent || "");
      if (t) t.remove();
      dot.removeAttribute("aria-label");

      dot.style.cursor = "pointer";
      dot.style.transition = "all 0.2s ease";
      dot.addEventListener("mouseenter", (e) => {
        tooltip.textContent = dotTitles.get(dot);
        tooltip.style.display = "block";
        tooltip.style.left = e.clientX + 10 + "px";
        tooltip.style.top = e.clientY + 10 + "px";
        dot.style.r = "8";
        dot.style.strokeWidth = "2";
        dot.style.filter = "brightness(1.2)";
      });
      dot.addEventListener("mousemove", (e) => {
        tooltip.style.left = e.clientX + 10 + "px";
        tooltip.style.top = e.clientY + 10 + "px";
      });
      dot.addEventListener("mouseleave", () => {
        tooltip.style.display = "none";
        dot.style.r = "5";
        dot.style.strokeWidth = "1.2";
        dot.style.filter = "none";
      });
    });
  }

  // Premier rendu + rerender si redimensionnement
  (async () => {
    await renderScatterResponsive();
    const container = document.querySelector(`[data-graph-id="${uniqueId}"]`);
    const holder = container?.querySelector(".plot-holder");
    if (!holder) return;
    const ro = new ResizeObserver(() => renderScatterResponsive());
    ro.observe(holder);
    window.addEventListener("orientationchange", renderScatterResponsive);
  })();
</script>
